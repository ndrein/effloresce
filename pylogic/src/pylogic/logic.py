'''
Created on Mar 28, 2011

logic.py

A python module for validation of propositional and first-order logic
statements.

Simple software verification can be achieved through use of this module. A basic
scenario is when you wish to confirm that some state is achieved after running a
block of code.  Typically this is done through unit tests. The trouble with unit
tests is that they require much effort to set up and typically only test as many
cases as the programmer's time can afford. Unit tests can be augmented with a
simple model that enumerates a representative set of inputs so that a logical
statement can be validated with a single call to logic.validate() or
Context.validate().

The simplest use of the logic module is to check the validity of propositional
logic statements. To evaluate propositional logic statements, see
logic.validate() or Context.validate(). Truth tables can also be printed with
Context.printTruthTable().

Unless you're testing very simple conditions and testing your logic, you
probably want to use first-order logic so that you can specify sets, define
relationships (between objects in a domain), and test using quantifiers (that a
statement is true for at least one object in the domain, or all objects).
Statements are verified by use of the Context.validate() function. A domain of
objects can be set on the context with Context.setTermDomain(), which takes a
list. 

Predicate functions can be defined either implicitly or explicitly. Implicit
predicate functions are defined through a call to Context.assume(sentence) or
Context.assumePredicate(predicate). Context.assume(sentence) will infer which
predicate invocations must be true in order to make sentence true.
Context.assumePredicate(predicate) will tell the logic engine that predicate is
necessarily true without requiring inferencing. Using this method leads to more
optimal performance in the validate() function. Finally Python functions can be
used to define predicate functions. You can tell a Context to use a Python
function by passing the function in as an argument to
Context.setPredicateFunction(function, arity).

For further documentation see individual function documentation or logic_examples.py

@author: Rob Truxler http://rob.truxler.com
@version: 1.0
'''

import lex
import yacc
import re
import copy

t_ignore = ' \t'

# set a regex that is used to parse the predciates that have a finite arity
# matches "some text(arg1, arg2)" for some positive number of args
_predPattern = re.compile("(?P<statement>.+)(\((?P<args>.+)\))")
        
        
def t_newline(t):
    r'\n+'
    t.lexer.lineno += t.value.count("\n")

def t_error(t):
    print("Illegal character '%s'" % t.value[0])
    t.lexer.skip(1)


def validate(sentence):
    ''' 
    Return True if sentence is a tautology in propositional logic. ie.
    validate("[propositional atom] and {[another atom] implies not [a third atom]}") returns False
    '''
    context = Context()
    return context.validate(sentence)

def satisfiable(sentence):
    '''
    Return True if a sentence is satisfiable in propositional logic. ie.
    satisfiable("[propositional atom] and {[another atom] implies not [a third atom]}") returns True
    '''
    context = Context()
    return context.satisfiable(sentence)

class LogicError(UserWarning):
    ''' 
    All errors generated by this module are LogicErrors and are either syntax
    errors or references to unbound terms that aren't in the first-order domain
    '''
    
    def __init__(self, message):
        super(LogicError, self).__init__(message)

class UnaryOp:
    expression = None
    
class FirstOrderUnaryOp(UnaryOp):
    
    boundVar = None
    
    def getBoundVariablePreds(self):
        '''
        Returns a list of predicate references to bound variables
        '''
        refs = []
        self._getBoundVariablePredsRecursive(refs, self.expression)
        return refs
    
    def _getBoundVariablePredsRecursive(self, refs, expression):
        '''
        Recursively looks for predicates that refer to bound variables
        '''
        
        if(isinstance(expression, Predicate)):
            if(expression.argList is not None and self.boundVar in expression.argList):
                refs.append(expression)
        elif(isinstance(expression, UnaryOp)):
            self._getBoundVariablePredsRecursive(refs, expression.expression)
        elif(isinstance(expression, BinaryOp)):
            self._getBoundVariablePredsRecursive(refs, expression.left)
            self._getBoundVariablePredsRecursive(refs, expression.right)
        
        
class BinaryOp:
    # no op
    left = None
    right = None
    
class PredicateFunction:
    
    def __init__(self, arity, function):
        self.arity = arity
        self.function = function

class Context:
    '''
    Provides a context for which logical statements can be validated.
    
    Propositional logic statements can be easily validated without a Context object.
    Propositional logic statements can be validated by calling logic.validate("statement"), but
    more complex logical statements, such as those involving first-order logical predicates and
    first-order quantifiers (exists, all), need to be validated within a context.
    '''
    
    def __init__(self):
        
        # list of objects for the first-order logic term domain
        self.domain = []
        
        # propositional atoms or predicates as a dictionary
        # key is the stringified version of the predicate
        self.predicates = {}
        
        # predicate invocations that we know to be true
        # or that we have previously calculated to be true
        self.predicateAssumptions = {}
        
        # logical statements assumed to be true
        self.assumptions = []
        
        # explicitly defined PredicateFunctions -- see the PredicateFunction class
        self.predicateFunctions = {}

    def _isSatisfiable(self, sentence, printTruthTable=False, truthTableSep="\t"):
        parseTree = self.parse(sentence)
        if(printTruthTable):
            self._printTruthTable(parseTree, truthTableSep)
        rows = self.getTruthRows(parseTree)
        return rows.count(True) >= 1

    def isTautology(self, sentence, printTruthTable=False, truthTableSep="\t"):
        # get number of unique predicates
        # produce 2^num_preds rows for a truth table
        # set predicate values based on above
        # evaluate sentence
        
        parseTree = self.parse(sentence)
        if(printTruthTable):
            self._printTruthTable(parseTree, truthTableSep)
        rows = self.getTruthRows(parseTree)
        return len(rows) == sum(rows)

    def clear(self):
        self.predicates.clear()
        self.assumptions.clear()
        self.predicateFunctions.clear()
        self.predicateAssumptions.clear()
        self.domain = None
        
    def assume(self, sentence):
        ''' assume that a logical sentence is true.
        This will affect the evaluation of future
        validation() calls, and can be undone with
        a call to clear()
        '''
        self.assumptions.append(sentence)
        
    def assumePredicate(self, predicate):
        if(predicate[0] == '[' or predicate[len(predicate) - 1] == ']'):
            raise LogicError("Predicates should not be wrapped in [ ] with assumePredicate")
#        self.assume("[" + predicate + "]")
        # keep this
        self.predicateAssumptions[predicate] = True
        
    def _replaceArg(self, expression, replaceThis, replaceWith):
        # to do: recursively find predicates, and replace their arguments that include replaceThis with replaceWith
        expr = expression;
        if(isinstance(expression, BinaryOp)):
            self._replaceArg(expression.left, replaceThis, replaceWith)
            self._replaceArg(expression.right, replaceThis, replaceWith)
            expression.left = self._checkForStoredPredicate(expression.left)
            expression.right = self._checkForStoredPredicate(expression.right)
        elif(isinstance(expression, UnaryOp)):
            self._replaceArg(expression.expression, replaceThis, replaceWith)
            expression.expression = self._checkForStoredPredicate(expression.expression)
        elif(isinstance(expression, Predicate)):
            argList = expression.argList
            if(argList is not None):
                for idx in range(len(argList)):
                    item = argList[idx]
                    if(item == replaceThis):
                        argList[idx] = replaceWith
            expr = self._checkForStoredPredicate(expression)
        return expr
                        
    def _checkForStoredPredicate(self, expression):
        ''' Look for an already stored version of this predicate (expression),
        and if it has already been stored, return that version. Otherwise return
        itself. This will keep from duplicate Predicate instances that have
        the same signature and arguments. '''
        
        if(isinstance(expression, Predicate)):
            s = expression.getFullStatement()
            if(s in self.predicates.keys() and self.predicates[s] is not None):
                return self.predicates[s]
        return expression
        
    def setPredicateFunction(self, function, arity, predString=None):
        ''' Provide a function to define the truth values for the predicate symbol
            over the values in the domain. This requires that a domain be set
            via setTermDomain
        '''
        
        assert arity > 0
        
        s = predString
        if(s is None):
            s = function.__name__
        self.predicateFunctions[s] = PredicateFunction(arity, function)
        
    def setTermDomain(self, domain_array):
        ''' Specify a term domain as a list for first-order logical statements.
        This can be a list of any type, but each element in the domain must
        have a unique value when cast as a string. Any time a predicate function
        is called it may be invoked with the string-cast version of the object
        in the domain. '''
        # copy the array, make it an array of strings
        stringified = []
        self.predicateAssumptions.clear()
        for x in domain_array:
            stringified.append(str(x))
        self.domain = stringified
        
    def forgetPredicateInvocations(self):
        ''' 
        Validate will remember which predicate invocations were true (with which
        arguments a predicate function was true). If the context has changed for
        some reason unknown to this Context object, you must call this method so
        that the predicate functions are invoked again
        '''
        
        self.predicateAssumptions.clear()
        
    def _buildPredicateAssumptionsFromFunctions(self):
        # enumerate all values in the domain, adding predicateAssumptions
        # if the value in the domain is true for the function
        for predName in self.predicateFunctions.keys():
            fn = self.predicateFunctions[predName]
            
            # produce an array for every possible combination
            # of arguments in this arity, then execute this
            # function over that array, and if it is true,
            # then add the predicateAssumption
            n = len(self.domain)
            a = fn.arity
            
            # total number of possible invocations: n^a
            numCombinations = n ** a
            for i in range(0, numCombinations):
                # i represents the ith argument pair
                args = []
                # now build the argument pair
                argIndices = [0] * a
                # convert to a radix of the domain length
                _toDomainRadix(i, n, argIndices, 0)
                for k in range(len(argIndices)):
                    args.append(self.domain[argIndices[k]])
                # the arguments are built, now see if we've computed their truth
                # before
                stringified = predName + "(" + ",".join(args) + ")"
                if(not stringified in self.predicateAssumptions.keys() and
                   fn.function(*args)):
                    self.assumePredicate(stringified)
    
    def printTruthTable(self, sentence, separator="\t"):
        ''' 
        print a truth table that includes all predicates or propositional atoms
        and the entire sentence. Note that the truth table does not include any
        other sub-formulas.
        
        Specify the separator with a second argument (default is a tab character).
        '''
        
        self.predicates.clear()
        
        # if we have a predicate function, let's first build the list of
        # predicateAssumptions based on that function
        if(len(self.predicateFunctions) > 0):
            self._buildPredicateAssumptionsFromFunctions()
        
        # construct a new sentence that is the conjunction of all assumptions
        newSentence = " and ".join("{" + str(x) + "}" for x in self.assumptions)
        
        if(len(newSentence) == 0):
            parseTree = self.parse(sentence)
            return self._printTruthTable(parseTree, separator)
        
        newSentence = "{" + newSentence + "} implies {" + sentence + "}"
        parseTree = self.parse(newSentence)
        return self._printTruthTable(parseTree, separator)
    
    def satisfiable(self, assertion, printTruthTable=False, truthTableSep="\t"):
        '''
        Return true if there is at least one valuation of the predicates or propositional atoms
        that makes this assertion true.
        '''
        
        self.predicates.clear()
        
        # if we have a predicate function, let's first build the list of
        # predicateAssumptions based on that function
        if(len(self.predicateFunctions) > 0):
            self._buildPredicateAssumptionsFromFunctions()
        
        # construct a new sentence that is the conjunction of all assumptions
        newSentence = " and ".join("{" + str(x) + "}" for x in self.assumptions)
        
        if(len(newSentence) == 0):
            return self._isSatisfiable(assertion, printTruthTable, truthTableSep)
        
        newSentence = "{" + newSentence + "} implies {" + assertion + "}"
        return self._isSatisfiable(newSentence, printTruthTable, truthTableSep)
        
    
    def validate(self, assertion, printTruthTable=False, truthTableSep="\t"):
        '''
        Evaluate an assertion of propositional or first-order logic. Optional
        arguments allow the caller to specify whether a truth table should be
        printed, and with what string as a separator between values.
        
        Returns True if the assertion is a tautology, false otherwise.
        '''
        
        self.predicates.clear()
        
        # if we have a predicate function, let's first build the list of
        # predicateAssumptions based on that function
        if(len(self.predicateFunctions) > 0):
            self._buildPredicateAssumptionsFromFunctions()
        
        # construct a new sentence that is the conjunction of all assumptions
        newSentence = " and ".join("{" + str(x) + "}" for x in self.assumptions)
        
        if(len(newSentence) == 0):
            return self.isTautology(assertion, printTruthTable, truthTableSep)
        
        newSentence = "{" + newSentence + "} implies {" + assertion + "}"
        return self.isTautology(newSentence, printTruthTable, truthTableSep)
    
    def _printTruthTable(self, parseTree, separator):
        # make a temporary array of the un-assumed predicates; that is, the predicate
        # for which we don't known their truth. This is all of the predicates in self.predicates
        # but it does not include the predicates in self.predicateAssumptions, since those
        # are all true.
        unknownPreds = copy.copy(self.predicates)
        # now remove all of the known predicates
        for key in self.predicateAssumptions.keys():
            p = Predicate(key, self.domain)
            p.truth = True
            self.predicates[key] = p
            if(key in unknownPreds):
                del unknownPreds[key]
                
        # provide any warnings for out-of-domain terms
        for key in self.predicates.keys():
            p = self.predicates[key]
            if(p.argList is not None):
                for term in p.argList:
                    if(not term in self.domain):
                        raise LogicError("WARNING: Term '" + str(term) + "' not in domain " + str(self.domain))
#            
#        for key in self.predicateAssumptions.keys():
#            del unknownPreds[key]
#            # set these to be true:
#            self.predicates[key].truth = True
        
        numPreds = len(self.predicates)
        numUnknownPreds = len(unknownPreds)
        rows = 2 ** numUnknownPreds
        header = ""
        for k in range (0, numPreds):
            header += str(list(self.predicates.keys())[k]) + separator
            
        header += str(parseTree)
        print(header)
        
        for i in range (0, rows):
            string = ""
            for k in range (0, numUnknownPreds):
                # get the predicate and set its truth
                pred = unknownPreds[list(unknownPreds.keys())[k]]
                # bit shift to get a boolean value
                pred.truth = (bool(1 << k & i))
            
            for k in range (0, numPreds):
                pred = self.predicates[list(self.predicates.keys())[k]]
                string += str(pred.truth) + separator
            string += str(parseTree.isTrue())
            print(string)
            
    def getTruthRows(self, parseTree):
        '''
        Return a list of truth values (one for each row that is computed) for
        each valuation of propositional atoms or predicate invocations.
        '''
        
        rowTruth = []
        
        # make a temporary array of the un-assumed predicates; that is, the predicate
        # for which we don't known their truth. This is all of the predicates in self.predicates
        # but it does not include the predicates in self.predicateAssumptions, since those
        # are all true.
        unknownPreds = copy.copy(self.predicates)
        # now remove all of the known predicates
#        print "unknownpreds is + " + str(self.predicates)
        for key in self.predicateAssumptions.keys():
            p = Predicate(key, self.domain)
            p.truth = True
            self.predicates[key] = p
            if(key in unknownPreds):
                del unknownPreds[key]
        
        # provide any warnings for out-of-domain terms
        for key in self.predicates.keys():
            p = self.predicates[key]
            if(p.argList is not None):
                for term in p.argList:
                    if(not term in self.domain):
                        raise LogicError("WARNING: Term '" + str(term) + "' not in domain " + str(self.domain))
#       
#        for key in self.predicateAssumptions.keys():
#            del unknownPreds[key]
#            # set these to be true:
#            self.predicates[key].truth = True
#            
#            print "trying to uncache pred key " + key
#            if (key in unknownPreds):
#                del unknownPreds[key]
#            # set these to be true:
#            self.predicates[key].truth = True
        
        numPreds = len(self.predicates)
        numUnknownPreds = len(unknownPreds)
        rows = 2 ** numUnknownPreds
        
        for i in range (0, rows):
            string = ""
            for k in range (0, numUnknownPreds):
                # get the predicate and set its truth
                pred = unknownPreds[list(unknownPreds.keys())[k]]
                # bit shift to get a boolean value
                pred.truth = (bool(1 << k & i))
            
            for k in range (0, numPreds):
                pred = self.predicates[list(self.predicates.keys())[k]]
                string += str(pred.truth) + "\t"
            rowTruth.append(parseTree.isTrue())
        return rowTruth
    
    def parse(self, sentence):
        ''' 
        Perform the actual parsing (lex/yacc), define and use the grammar for
        propositional and first-order logic.
        
        Builds a parse tree and returns the root (an operator with the lowest precedent).
        '''
        
        # build the lexer
        
        # eclipse may warn you that this is an unused variable, but lex will use it
        tokens = (
                  'LBRACE', 'RBRACE', 'AND', 'OR', 'IMPLIES', 'NOT', 'ALL', 'EXISTS',
                  'PREDICATE', 'BINDING'
                  )
        
        #### DEFINE EVERY TOKEN MATCH AS A FUNCTION ###
        # this has the important side-effect of being able
        # to strictly control order of lexical matching
        
        def t_LBRACE (t): 
            r'\{'
            return t
        def t_RBRACE (t): 
            r'\}'
            return t
        def t_PREDICATE(t): 
            '\[[^\]]+\]'
            return t
        
        def t_AND(t):
            r'and'
            return t
        def t_OR(t):
            r'or'
            return t
        def t_IMPLIES(t):
            r'implies|therefore'
            return t
        
        def t_NOT(t):
            r'not'
            return t
        
        def t_ALL(t):
            r'all'
            return t
        
        def t_EXISTS(t):
            r'exists'
            return t
        
        def t_BINDING(t):
            r'[a-zA-Z_][a-zA-Z_0-9]*'
            return t
            
        # eclipse will warn you that this is an unused variable, but yacc/lex will use it
        precedence = (
                      ('left', 'IMPLIES'),
                      ('left', 'OR', 'AND'),
                      ('left', 'EXISTS', 'ALL'),
                      ('left', 'NOT'),
                      ('left', 'PREDICATE')
                      )
        
        # Build the lexer
        # again, eclipse will warn about this being an unused variable, but yacc will use it
        lexer = lex.lex()
        
        
        def p_expression_not(p):
            'expression : NOT expression'
            p[0] = Negation(p[2])
                
        def p_expression_forall_pred(p):
            'expression : ALL BINDING expression'
            p[0] = All(self, str(p[2]), self.domain, p[3])
            preds = p[0].getBoundVariablePreds()
            for x in preds:
                if(x.getFullStatement() in list(self.predicates.keys())):
                    del self.predicates[x.getFullStatement()]
            
        def p_expression_exists_pred(p):
            'expression : EXISTS BINDING expression'
            p[0] = Exists(self, str(p[2]), self.domain, p[3])
            preds = p[0].getBoundVariablePreds()
            for x in preds:
                if(x.getFullStatement() in list(self.predicates.keys())):
                    del self.predicates[x.getFullStatement()]
        
        def p_expression_implies(p):
            'expression : expression IMPLIES expression'
            p[0] = Implication(p[1], p[3])
            
            
        def p_expression_and(p):
            'expression : expression AND expression'
            p[0] = Conjunction(p[1], p[3])
            
        def p_expression_or(p):
            'expression : expression OR expression'
            p[0] = Disjunction(p[1], p[3])
        
        def p_expression_group(p):
            'expression : LBRACE expression RBRACE'
            p[0] = p[2]
            
#        def p_expression_term(p):
#            'expression : predicate'
#            p[0] = p[1]
            
        def p_predicate(p):
            'expression : PREDICATE'
            
            stringified = str(p[1])[1:len(str(p[1])) - 1]
            
            if(stringified in self.predicates):
                p[0] = self.predicates[stringified]
            else:
                p[0] = Predicate(stringified, self.domain)
                self.predicates[stringified] = p[0]
                if(stringified in self.predicateAssumptions):
                    p[0].truth = True
                
        # Error rule for syntax errors
        def p_error(p):
            # get the position
            if p is None: return
            pos = p.lexpos
            # get the nth line
            lines = p.lexer.lexdata.split("\n");
            inp = lines[p.lexer.lineno - 1]
            
            hint = "Unexpected operator or predicate not wrapped in []"
            
            if(inp[pos - 1] == '['):
                hint = "no matching closing bracket ']' after this point"
            if(inp[pos - 1] == '{'):
                hint = "no matching closing brace '}' after this point"
            if(inp[pos] == '}'):
                hint = "no matching opening brace '{' before this point"
            if(inp[pos] == ']'):
                hint = "no matching opening bracket '[' before this point"
            
            raise LogicError("Syntax error at line " + str(p.lexer.lineno) + ", character " + str(pos) + ":\n" + inp + "\n" + (pos * " ") + "^ " + hint);
        
        parser = yacc.yacc("LALR",0)

        parseTree = parser.parse(sentence)
        
        # return the outer-most (lowest priority) operator in this sentence -- it serves as the
        # root to the parse tree
        return parseTree

class Disjunction(BinaryOp):

    def __init__(self, exprLeft, exprRight):
        self.left = exprLeft
        self.right = exprRight
    
    def isTrue(self):
        return (self.left.isTrue() or self.right.isTrue()) 

    def __str__(self):
        return "{" + str(self.left) + " or " + str(self.right) + "}"

class Conjunction(BinaryOp):

    def __init__(self, exprLeft, exprRight):
        self.left = exprLeft
        self.right = exprRight
    
    def isTrue(self):
        return (self.left.isTrue() and self.right.isTrue()) 

    def __str__(self):
        return "{" + str(self.left) + " and " + str(self.right) + "}"

class Predicate:
    '''
    A Predicate object can represent a propositional atom (which is equivalent
    to a first-order logic predicate function with arity 0), or a first-order
    logical predicate function (with positive arity) invocation. The statement
    should include the predicate name, plus parenthesis which include a comma-
    separated list of arguments if the predicate function has a positive arity.
    '''

    def __init__(self, statement, domain):
        '''
        Constructor
        '''
        self.statement = statement
        self.argList = None
        self.domain = domain
        self._parseArguments(statement)
        self.truth = False
    
    def _parseArguments(self, statement):
        result = _predPattern.match(statement)
        if(result):
            self.statement = result.group("statement")
            #        self.argList = result.group("args").split(",")
            argList = result.group("args").split(",")
            for i in range(len(argList)):
                argList[i] = argList[i].strip()
            self.argList = argList
        else:
            self.statement = statement
        
    def isTrue(self):
        '''
        NB: regardless of explicitly defined predicate functions, this Predicate object
        has a static truth, that is set by the validation function.
        '''
        if(self.argList is not None):
            for term in self.argList:
                if(not term in self.domain):
                    raise LogicError("WARNING: Term '" + str(term) + "' not in domain " + str(self.domain))
        return self.truth
    
    def getFullStatement(self):
        '''
        Return the full string version of this Predicate, which includes the
        name and its arguments (comma-separated, wrapped in parenthesis).
        '''
        s = self.statement
        if(self.argList is not None):
            s = s + "(" + (",".join(self.argList)) + ")"
        return s
    
    def __str__(self):
        return "[" + self.getFullStatement() + "]"


class Negation(UnaryOp):
    
    def __init__(self, expr):
        self.expression = expr
        
    def isTrue(self):
        return not self.expression.isTrue();

    def __str__(self):
        return "{not " + str(self.expression) + "}"

class Exists(FirstOrderUnaryOp):
    
    def __init__(self, context, boundVariable, domain, expression):
        self.context = context
        self.boundVar = boundVariable
        self.expression = expression
        # go through the expression and remove any predicates that reference bound variables
        # from the predicates array
        self.domain = domain
        
    def isTrue(self):
        # this is the hard part
        # need to loop through each variable in the domain, asking if there is a variable, x, that satisfies the domain
        if(self.domain is None):
            return False
        for x in self.domain:
            exp = copy.deepcopy(self.expression)
            exp = self.context._replaceArg(exp, self.boundVar, x)
            if(exp.isTrue()): 
                return True
        return False
       
    def __str__(self):
        return "exists " + self.boundVar + " {" + str(self.expression) + "}"

class All(FirstOrderUnaryOp):
    
    def __init__(self, context, boundVariable, domain, expression):
        self.context = context
        self.boundVar = boundVariable
        self.expression = expression
        # go through the expression and remove any predicates that reference bound variables
        # from the predicates array
        self.domain = domain
        
    def isTrue(self):
        # this is the hard part
        # need to loop through each variable in the domain, asking if there is a variable, x, that satisfies the domain
        if(self.domain is None):
            return False
        for x in self.domain:
            exp = copy.deepcopy(self.expression)
            exp = self.context._replaceArg(exp, self.boundVar, x)
            if(not exp.isTrue()): 
                return False
        return True
       
    def __str__(self):
        return "all " + self.boundVar + " {" + str(self.expression) + "}"
    

class Implication (BinaryOp):
    
    def __init__(self, expr1, expr2):
        self.left = expr1;
        self.right = expr2;
    
    def isTrue(self):
        if(self.left.isTrue() and (not self.right.isTrue())):
            return False
        return True
    
    def __str__(self):
        return "{" + str(self.left) + " implies " + str(self.right) + "}"

def _toDomainRadix(m, n, arr, idx):
    '''
    Takes an integer, m, and populates an array with integers from
    0 to n-1 that represent the result of converting m to base-n radix.
    '''
    if(n == 1): return
    if(m < n):
        arr[idx] = m
    else:
        _toDomainRadix(int(m / n), n, arr, idx + 1)
        arr[idx] = (m % n)
